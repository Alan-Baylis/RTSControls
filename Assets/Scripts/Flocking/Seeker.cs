using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;

/// <summary>
/// Seeker.
/// Use this as a start for your seeker homework.
/// </summary>

[RequireComponent(typeof(Steering))]
[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(Dimensions))]


public class Seeker : MonoBehaviour
{
	// These variables will be exposed in the Inspector window
	public GameObject target  = null;
	
	public float seekWt = 10.0f;
	public float avoidWt = 30.0f;
	public float avoidDist = 30.0f;
	
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	
	// the steering component implements the basic steering functions
	private Steering steering;
	
	// movement variables
	private float gravity = 20.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;
	
	//reference to an array of obstacles
	private  GameObject[] obstacles; 
	
	//used for the reset button
	private Vector3 startPos;

	
	public void Start ()
	{
		//get component references
		characterController = gameObject.GetComponent<CharacterController> ();
		steering = gameObject.GetComponent<Steering> ();
		moveDirection = transform.forward;
		startPos = transform.position;
		
	
		// uncomment the following line if you have created a tag and applied it to the obstacle prefab
		obstacles = GameObject.FindGameObjectsWithTag ("Obstacle");
	}
	
	
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		// movedirection equals velocity
		moveDirection = transform.forward * steering.Speed;
		
		//add acceleration, modified for dt
		moveDirection += steeringForce * Time.deltaTime;
		 
		//update speed
		steering.Speed = moveDirection.magnitude;
		if (steering.Speed != moveDirection.magnitude) {
			moveDirection = moveDirection.normalized * steering.Speed;
		}
		//orient transform
		if (moveDirection != Vector3.zero)
			transform.forward = moveDirection;
		
		// Apply gravity
		moveDirection.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (moveDirection * Time.deltaTime);
	}
	
	
	// OnGUI is called by the system, like Update, on every frame cycle
	private void OnGUI ()
	{
		// we wrap the button in an if statement, which catches a "true" if the button is pressed
		if (GUI.Button (new Rect (20, 20, 100, 30), "restart")) 
		{
			transform.position = startPos;
		}
	}

	
	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steering.maxForce) 
		{
			steeringForce.Normalize ();
            steeringForce *= steering.maxForce;
		}
	}
	
	private void CalcSteeringForce ()
	{
		steeringForce = Vector3.zero;
		steeringForce += seekWt * steering.Seek (target.transform.position);

        GameObject closestObstacle = getNearestObstacle();
        steeringForce += avoidWt * steering.AvoidObstacle(closestObstacle, avoidDist);
	}

    private GameObject getNearestObstacle()
    {
        GameObject closestObstacle = obstacles[0];
        float closestDist = Vector3.Distance(transform.position, closestObstacle.transform.position);
        foreach (GameObject o in obstacles)
        {
            float dist = Vector3.Distance(transform.position, o.transform.position);
            if (dist < closestDist)
            {
                closestObstacle = o;
                closestDist = dist;
            }
        }

        Debug.Log("Closest obstacle: " + closestObstacle.name);

        return closestObstacle;
    }
	
	
	
}



