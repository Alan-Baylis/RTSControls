using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;

//directives to enforce that our parent Game Object required components
[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(Steering))]

public class Flocking : MonoBehaviour
{
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	private Steering steering;
	private FlockManager flockManager;

	// a unique identification number assigned by the flock manager 
	private int index = -1;
	public int Index {
		get { return index; }
		set { index = value; }
	}
	
	//movement variables
	private float gravity = 20.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;

	//list of nearby flockers
	private List<GameObject> nearFlockers = new List<GameObject> ();
	private List<float> nearFlockersDistances = new List<float> ();
	
	public void Start ()
	{
		//get component references
		characterController = gameObject.GetComponent<CharacterController> ();
		steering = gameObject.GetComponent<Steering> ();
		
		flockManager = FlockManager.Instance;
	}

	// get a reference to the manager's FlockManager component (script)
	public void setFlockManager (GameObject fManager)
	{
		flockManager = fManager.GetComponent<FlockManager> ();
	}

	
	private Vector3 Alignment ()
	{
		return steering.AlignTo (flockManager.FlockDirection);
	}

	
	private Vector3 Cohesion ()
	{
		return steering.Seek (flockManager.Centroid);
	}


	private Vector3 Separation ()
	{
		//empty our lists
		nearFlockers.Clear ();
		nearFlockersDistances.Clear ();
		
		float dist;
		//******* write this - it won't work as is ***********

        List<GameObject> flockers = flockManager.Flockers;
        foreach (GameObject flocker in flockers)
        {
            if (flocker.gameObject.Equals(this.gameObject)) continue;

            dist = Vector3.Distance(transform.position, flocker.transform.position);
            if (dist < flockManager.separationDist)
            {
                nearFlockers.Add(flocker);
                nearFlockersDistances.Add(dist);
            }
        }

        Vector3 fleeVectorSum = Vector3.zero;
        for (int i = 0; i < nearFlockers.Count; ++i)
        {
            GameObject flocker = nearFlockers[i];
            float distance = nearFlockersDistances[i];

            Vector3 fleeVector = steering.Flee(flocker);
            fleeVector.Normalize();

            fleeVectorSum += fleeVector * (1 / distance); // weight inversely proportional to distance
        }
        fleeVectorSum.Normalize();
		
		Vector3 dv = fleeVectorSum * steering.Speed;
        dv -= steering.Velocity; // TODO: needed? is in slides

		return steering.AlignTo(dv);
	}

		

	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steering.maxForce) {
			steeringForce.Normalize ();
			steeringForce *= steering.maxForce;
		}
	}
	
	
	// tether type containment - not very good!
	private Vector3 StayInBounds ( float radius, Vector3 center)
	{
		if(Vector3.Distance(transform.position, center) > radius)
			return steering.Seek (center);
		else
			return Vector3.zero;
	}
	
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		moveDirection = transform.forward * steering.Speed;
		// movedirection equals velocity
		//add acceleration
		moveDirection += steeringForce * Time.deltaTime;
		//update speed
		steering.Speed = moveDirection.magnitude;
		if (steering.Speed != moveDirection.magnitude) {
			moveDirection = moveDirection.normalized * steering.Speed;
		}
		//orient transform
		if (moveDirection != Vector3.zero)
			transform.forward = moveDirection;
		
		// Apply gravity
		moveDirection.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (moveDirection * Time.deltaTime);
	}



	private void CalcSteeringForce ()
	{
		steeringForce = Vector3.zero;
		//steeringForce += transform.forward; //just to see if they move!
		steeringForce += flockManager.inBoundsWt * StayInBounds (150, new Vector3 (300, 30, 300));
		steeringForce += flockManager.alignmentWt * Alignment ();
		steeringForce += flockManager.cohesionWt * Cohesion ();
		steeringForce += flockManager.separationWt * Separation ();

        foreach (GameObject obstacle in flockManager.Obstacles)
        {
            steeringForce += flockManager.avoidWt * steering.AvoidObstacle(obstacle, flockManager.avoidDist);
        }
	}
	
}